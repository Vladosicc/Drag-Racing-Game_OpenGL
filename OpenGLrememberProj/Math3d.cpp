#include "Math3d.h"
#include <math.h>

// * Нахождение нормали полигона * \\
 
// Чтобы найти нормаль полигона, нам нужно найти результат cross-a от двух
// векторов этого полигона. В общем, это всё, что нам нужно для получения направлений
// двух сторон треугольника. В конце концов, вектор - это только направление и длинна.
// Длинна вектора в нашем случае не важна. Нам нужно только узнать направление.
// Итак, имея 2 вектора треугольника, мы можем найти вектор, стоящий перпендикулярно
// к полигону.
// Теперь, в зависимости от порядка следования вершин, нормаль будет расположена с
// какой-то из сторон полигона. Вам остаётся только решить, в каком порядке отрисовывать
// вершины - ВСЕГДА запоминайте это.
// Обычно полигоны отрисовываются только с одной стороны. Никому не нужно второй раз
// отрисовывать сторону, которую не видно. Задумайтесь, если у вас есть какая-нибуть 3д
// модель, нужно ли вам отрисовывать внутренние стороны её полигонов? Конечно нет,
// это безсмысленно.
//


/////////////////////////////////////// CROSS \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	Возвращает вектор, перпендикулярный 2м переданным.
/////
/////////////////////////////////////// CROSS \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

CVector3 Cross(CVector3 vVector1, CVector3 vVector2)
{
	CVector3 vNormal;						// результирующий вектор

	// Еще раз, если у нас есть 2 вектора (2 стороны полигона), у нас есть плоскость.
	// cross находит вектор, перпендикулярный плоскости, составляемой 2мя векторами.
	// Формула в принципе проста, но сложна для запоминания:

	// The X value for the vector is:  (V1.y * V2.z) - (V1.z * V2.y)
	vNormal.x = ((vVector1.y * vVector2.z) - (vVector1.z * vVector2.y));

	// The Y value for the vector is:  (V1.z * V2.x) - (V1.x * V2.z)
	vNormal.y = ((vVector1.z * vVector2.x) - (vVector1.x * vVector2.z));

	// The Z value for the vector is:  (V1.x * V2.y) - (V1.y * V2.x)
	vNormal.z = ((vVector1.x * vVector2.y) - (vVector1.y * vVector2.x));

	return vNormal;	 // Возвращаем результат (направление, куда направлен полигон - нормаль)
}

/////////////////////////////////////// VECTOR \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	Возвращает вектор между 2мя точками.
/////
/////////////////////////////////////// VECTOR \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

CVector3 Vector(CVector3 vPoint1, CVector3 vPoint2)
{
	CVector3 vVector = { 0 };

	// Чтобы получить вектор между 2 точками (направление), нужно вычесть вторую
	// точку из первой.

	vVector.x = vPoint1.x - vPoint2.x;
	vVector.y = vPoint1.y - vPoint2.y;
	vVector.z = vPoint1.z - vPoint2.z;

	// Теперь возвращаем полученный результат

	return vVector;
}

/////////////////////////////////////// MAGNITUDE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	возвращает величину нормали
/////
/////////////////////////////////////// MAGNITUDE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

float Magnitude(CVector3 vNormal)
{
	return (float)sqrt((vNormal.x * vNormal.x) +
		(vNormal.y * vNormal.y) +
		(vNormal.z * vNormal.z));
}

/////////////////////////////////////// NORMALIZE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	возвращает нормализованный вектор (с длинной 1)
/////
/////////////////////////////////////// NORMALIZE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

CVector3 Normalize(CVector3 vNormal)
{
	float magnitude = Magnitude(vNormal);

	vNormal.x /= magnitude;
	vNormal.y /= magnitude;
	vNormal.z /= magnitude;

	return vNormal;
}

/////////////////////////////////////// NORMAL \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	Возвращает нормаль полигона
/////
/////////////////////////////////////// NORMAL \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

CVector3 Normal(CVector3 vTriangle[])
{
	CVector3 vVector1 = Vector(vTriangle[2], vTriangle[0]);
	CVector3 vVector2 = Vector(vTriangle[1], vTriangle[0]);

	// В функцию передаются три вектора - треугольник. Мы получаем vVector1 и vVector2 - его
	// стороны. Теперь, имея 2 стороны треугольника, мы можем получить из них cross().
	// (*ЗАМЕЧАНИЕ*) Важно: первым вектором мы передаём низ треугольника, а вторым - левую
	// сторону. Если мы поменяем их местами, нормаль будет повернута в противоположную
	// сторону. В нашем случае мы приняли решение всегда работать против часовой.

	CVector3 vNormal = Cross(vVector1, vVector2);

	// Теперь, имея направление нормали, осталось сделать последнюю вещь. Сейчас её
	// длинна неизвестна, она может быть очень длинной. Мы сделаем её равной 1, это
	// называется нормализация. Чтобы сделать это, мы делим нормаль на её длинну.
	// Ну а как найти длинну? Мы используем эту формулу: magnitude = sqrt(x^2 + y^2 + z^2)

	vNormal = Normalize(vNormal);

	// Теперь вернём "нормализованную нормаль" =)
	// (*ПРИМЕЧАНИЕ*) если вы хотите увидеть, как работает нормализация, закомментируйте
	// предидущую линию. Вы увидите, как длинна нормаль до нормалицации. Я стого рекомендую
	// всегда использовать эту функцию. И запомните, неважно, какова длинна нормали 
	// (конечно, кроме (0,0,0)), если мы её нормализуем, она всегда будет равна 1.

	return vNormal;
}

float PlaneDistance(CVector3 Normal, CVector3 Point)
{
	float distance = 0;	// Переменная хранит дистанцию плоскости от начала координат

	// Используем уравнение плоскости для нахождения дистанции (Ax + By + Cz + D = 0).
	// Нам нужно найти D. Больше информации об уравнении плоскости будет ниже (в IntersectedPlane()).
	// Основное: A B C - это значения X Y Z нашей нормали, а x y z - это x y z нашей точки.
	// D - дистанция от начала координат. Итак, нам нужно воспользоваться этим уравнением, чтобы найти D.
	distance = -((Normal.x * Point.x) + (Normal.y * Point.y) + (Normal.z * Point.z));

	return distance;	// Возвратим дистанцию
}


// С прошлого урока мы добавим ещё 2 параметра для нормали и дистанции в функцию IntersectedPlane().
// Это делается, чтобы не пересчитывать всё три раза в IntersectionPoint() и IntersectedPolygon().
// Может быть потом мы даже сделаем разные функции, чтобы выбирать, хотим ли мы рассчитать заодно
// нормаль и дистанцию. Я также заменил vTriangle на "vPoly", так как это не обязательно должен быть
// треугольник.
// Итак, изменяем функцию IntersectedPlane():

bool IntersectedPlane(CVector3 vPoly[], CVector3 vLine[], CVector3& vNormal, float& originDistance)
{
	float distance1 = 0, distance2 = 0;		// Дистанция 2х точек линии

	vNormal = Normal(vPoly);		// Рассчитываем нормаль плоскости

	// Найдем дистанцию плоскости от начала координат:
	originDistance = PlaneDistance(vNormal, vPoly[0]);

	// Получим дистанции от первой и второй точек:
	distance1 = ((vNormal.x * vLine[0].x) +					// Ax +
		(vNormal.y * vLine[0].y) +					// Bx +
		(vNormal.z * vLine[0].z)) + originDistance;	// Cz + D

	distance2 = ((vNormal.x * vLine[1].x) +					// Ax +
		(vNormal.y * vLine[1].y) +					// Bx +
		(vNormal.z * vLine[1].z)) + originDistance;	// Cz + D


// Проверим на пересечение

	if (distance1 * distance2 >= 0)
		return false;

	return true;
}



// Следующая функция производит "рассчет оператора точки" (Dot product):
float Dot(CVector3 vVector1, CVector3 vVector2)
{
	// Вот формула Dot product: V1.V2 = (V1.x * V2.x  +  V1.y * V2.y  +  V1.z * V2.z)
	// В математическом представлении она выглядит так: V1.V2 = ||V1|| ||V2|| cos(theta)
	// '.' называется DOT. || || - величина, она всегда положительна. То есть величина V1
	// умножить на величину V2 умножить на косинус угла. Выглядит устрашающе, но позже станет
	// яснее. Эта функция используются во множестве ситуаций, которые будут описаны в других
	// уроках. В этом уроке с её помощью мы будем получать угол между двумя векторами.
	// Если векторы нормализованы, dot product вернет косинус угла между 2мя векторами.
	// Что это значит? Это значит, что на самом деле возвращается не сам угол, а cos(angle).
	// Ну а что если мы хотим получить сам угол? Тогда мы используем аркосинус. 
	// Больше об этом будет написано в функции AngleBetweenVectors(). Давайте рассмотрим
	// пример использования dot product. Как вычислить угол между перпендикулярными векторами?
	// Если мы нормализуем вектор, мы можем получить результат ||V1|| * ||V2||, останется только
	// найти cos(theta). Если вектор нормализован, его величина - 1, так что получится 1*1*cos(theta),
	// что бессмысленно, так что мы отбрасываем эту часть формулы. Итак, что такое косинус 90?
	// Если вы возьмете калькулятор, то узнает, что это 0. И получается, что если результат Dot()
	// равен нулю, векторы перпендикулярны. Всё что мы делали - получили аркосинус нуля, который
	// равен 90.

		 //    (V1.x * V2.x        +        V1.y * V2.y        +        V1.z * V2.z)
	return ((vVector1.x * vVector2.x) + (vVector1.y * vVector2.y) + (vVector1.z * vVector2.z));
}

////////////////////////////////////////////////////////////////////////////////
//
// Следуюшая функция возвращает угол между векторами
//
////////////////////////////////////////////////////////////////////////////////

double AngleBetweenVectors(CVector3 Vector1, CVector3 Vector2)
{
	// Помните, выше мы говорили, что Dot product возвращает косинус угла между 
	// двумя векторами? Подразумевается, что векторы нормализованы. И, если у нас нет 
	// нормализованного вектора, то просто делаем arcCos(DotProduct(A, B))
	// Нам нужно разделить dot product на величину двух умноженных друг на друга
	// векторов. Вот формула: arc cosine of (V . W / || V || * || W || )
	// ||V|| - это величина V. Это "отменит" величины dot product.
	// Но если вы уже нормализовали векторы, вы можете забыть о величинах.

	// Получаем Dot от обоих векторов
	float dotProduct = Dot(Vector1, Vector2);

	// Получаем умножение величин обоих векторов
	float vectorsMagnitude = Magnitude(Vector1) * Magnitude(Vector2);


	// Получаем аркосинус от (dotProduct / vectorsMagnitude), что есть угол в градусах.
	double angle = acos(dotProduct / vectorsMagnitude);


	// Теперь убедимся, что угол не -1.#IND0000000, что означает "недостижим". acos() видимо
	// считает прикольным возвращать -1.#IND0000000. Если мы не сделаем этой проверки, результат
	// проверки пересечения будет иногда показывать true, когда на самом деле пересечения нет.
	// я выяснил эту фичу тяжким трудом после МНОГИХ часов и уже написанных неверных уроков ;)
	// Обычно это значение возвращается, когда dot product и величина имеют одинаковое значение.
	// Мы вернём 0 если это случается.

	if (_isnan(angle))
		return 0;

	// Вернем угол в градусах
	return(angle);
}



/////////////////////////////////// INTERSECTION POINT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	Возвращает точку пересечения линии и плоскости
/////
/////////////////////////////////// INTERSECTION POINT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

CVector3 IntersectionPoint(CVector3 vNormal, CVector3 vLine[], double distance)
{
	CVector3 vPoint = { 0 }, vLineDir = { 0 };		// Переменные для точки пересечения и направления линии
	double Numerator = 0.0, Denominator = 0.0, dist = 0.0;


	// Здесь немного сложная часть. Нам нужно найти 3д точку, находящуюся на плоскости.
	// Вот шаги для реализации этого:

	// 1) Сначала нам нужно получить вектор нашей линии, затем нормализовать его, чтобы длинна была 1
	vLineDir = Vector(vLine[1], vLine[0]);		// Получим вектор линии
	vLineDir = Normalize(vLineDir);			// Нормализуем его


	// 2) Используем формулу плоскости (дистанция = Ax + By + Cz + D) чтобы найти дистанцию от одной из
	// точек до плоскости. Делаем дистанцию отрицательной, т.к. нам нужно идти НАЗАД от нашей точки
	// к плоскости. Это действие просто возвращает назад к плоскости, чтобы найти точку пересечения.

	Numerator = -(vNormal.x * vLine[0].x +		// Используем формулу плоскости с нормалью и линией
		vNormal.y * vLine[0].y +
		vNormal.z * vLine[0].z + distance);

	// 3) Если мы получим Dot product между вектором нашей линии и нормалью полигона,
	// это даст нам косинус угла между 2мя (т.к. они обе нормализованы - длинна 1).
	// Затем мы разделим Numerator на это значение чтобы найти отстояние плоскости от начальной точки.

	Denominator = Dot(vNormal, vLineDir);	// Получаем Dot pruduct между линией и нормалью

	// Так как мы используем деление, нужно уберечься от ошибки деления на ноль. Если мы получим 0, 
	// это значит, это НЕДОСТИЖИМАЯ точка, т.к. линая находится на плоскости (нормаль перпендикулярна
	// к линии - (Normal.Vector = 0)).
	// В этом случае просто вернем любую точку на линии.

	if (Denominator == 0.0)		// Проверим, не делим ли мы на ноль
		return vLine[0];	// Вернем любую точку линии


	// Мы делим (дистанция от отчки до плоскости) на (dot product), чтобы получить дистанцию
	// (dist), которая нужна нам для движения от начальной точки линии. Нам нужно умножить эту дистанцию (dist)
	// на вектор линии (направление). Когда вы умножаете scalar на ветор, вы двигаетесь вдоль
	// этого вектора. Это и есть то, что мы делаем. Мы двигаемся от нашей начальной точки, выбранной
	// на линии, НАЗАД к плоскости вдоль вектора линии. Логично было бы просто получить Numerator,
	// который является дистанцией от точки до линии, а потом просто двигатся назад вдоль вектора линии.
	// Дистанция от плоскости - имеется в виду САМАЯ КОРОТКАЯ дистанция. Что если линия почти параллельна
	// полигону, и не пересекается с ним на протяжении своей длинны? Расстояние до плоскости мало, но 
	// расстояние до точки пересечения вектора линии с плоскостью очень велико. Если мы разделим
	// дистанцию на dot product из вектора линии и нормали плоскости, то получим правильную длинну.

	dist = Numerator / Denominator;

	// Теперь, как и говорилось выше, делим дистанцию на вектор, потом добавляем точку линии.
	// Это переместит точку вдоль вектора на некую дистанцию. Это в свою очередь даст
	// нам точку пересечения.

	vPoint.x = (float)(vLine[0].x + (vLineDir.x * dist));
	vPoint.y = (float)(vLine[0].y + (vLineDir.y * dist));
	vPoint.z = (float)(vLine[0].z + (vLineDir.z * dist));

	return vPoint;			// Вернем точку пересечения.
}


/////////////////////////////////// INSIDE POLYGON \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	Проверяет, находится ли точка внутри полигона
/////
/////////////////////////////////// INSIDE POLYGON \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

bool InsidePolygon(CVector3 vIntersection, CVector3 Poly[], long verticeCount)
{
	const double MATCH_FACTOR = 0.9999;		// Исп. для покрытия ошибки плавающей точки
	double Angle = 0.0;				// Инициализируем угол
	CVector3 vA, vB;				// Временные векторы

	// Одно то, что линия пересекает плоскость, ещё не значит, что она пересекает полигон в 
	// этой плоскости. Эта функция проверяет точку пересечения на предмет того, находится ли
	// она внутри полигона. 
	// На самом деле мы используем замечательный метод. Он создает треугольники внутри
	// полигона от точки пересечения, проводя линии к каждой вершине полигона. Потом все углы 
	// созданных треугольников складываются. И если сумма углов равна 360, то мы внутри! 
	// Если же значение меньше 360, мы снаружи полигона. 
	// Чтобы лучше понять, как это работает, возьмите карандаш и нарисуйте
	// равносторонний треугольник. Нарисуйте точку в его центре. Теперь от этой точки проведите линии
	// к каждой вершине треугольника. Таким образом у нас получилось 3 треугольника внутри главного, верно?
	// Теперь. Мы знаем, что если сложим все углы треугольника, то получим 180, верно?
	// Почти в точности это мы и делаем. 

	for (int i = 0; i < verticeCount; i++)		// Проходим циклом по каждой вершине и складываем их углы
	{
		vA = Vector(Poly[i], vIntersection);	// Вычитаем точку пересечения из текущей вершины

		// Вычитаем точку пересечения из следующей вершины:
		vB = Vector(Poly[(i + 1) % verticeCount], vIntersection);

		// Находим угол между 2мя векторами и складываем их все
		Angle += AngleBetweenVectors(vA, vB);
	}

	// Теперь имея сумму углов, нам нужно проверить, равны ли они 360. Так как мы используем
	// Dot product, мы работаем в радианах, так что проверим, равны ли углы 2*PI. PI мы обьявили в 3dmath.h.
	// Вы заметите, что мы используем MATH_FACTOR. Мы используем его из-за неточности в рассчетах 
	// с плавающей точкой. Обычно результат не будет ровно 2*PI, так что нужно учесть маленькую
	// погрешность. Я использовал .9999, но вы можете изменить это на ту погрешность, которая вас 
	// устроит.

	if (Angle >= (MATCH_FACTOR * (2.0 * PI)))	// Если угол >= 2PI (360 градусов)
		return true;				// Точка находится внутри полигона

	return false;		// Иначе - снаружи
}


/////////////////////////////////// INTERSECTED POLYGON \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	Проверяет, пересекается ли линия с полигоном
/////
/////////////////////////////////// INTERSECTED POLYGON \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

bool IntersectedPolygon(CVector3 vPoly[], CVector3 vLine[], int verticeCount)
{
	CVector3 vNormal = { 0 };
	float originDistance = 0;

	// Сначала проверяем, пересекает ли наша линия плоскость. Если нет - то не нужно
	// продолжать, полигон на плоскости она тоже не пересекает.
	// Передаем в функцию адрес vNormal и originDistance, IntersectedPlane вычислит их для нас.

					   // Указатель   // Указатель
	if (!IntersectedPlane(vPoly, vLine, vNormal, originDistance))
		return false;

	// Теперь, имея нормаль и дистанцию, мы можем использовать их для нахождения точки
	// пересечения. Точка пересечения - это точка, находящаяся НА плоскости и НА линии.
	// Чтобы найти точку пересечения, передаем в функцию нормаль плоскости, точки линии и 
	// ближайшую дистанцию до плоскости.

	CVector3 vIntersection = IntersectionPoint(vNormal, vLine, originDistance);

	// Теперь, имея точку пересечения, нужно проверить, лежит ли она внутри полигона.
	// Чтобы сделать это, передаём:
	// (точка пересечения, полигон, количество вершин полигона).

	if (InsidePolygon(vIntersection, vPoly, verticeCount))
		return true;			// Есть пересечение! Вернём true


	// Если мы дошли досюда, пересечения нет, вернём false

	return false;
}
